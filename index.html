<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Raw Data Parser (ë¸Œëœë”©1íŒ€)</title>
<style>
  /* ===== Base UI ===== */
  body { font-family: "Noto Sans KR", sans-serif; margin: 20px; }
  h1 { margin-top: 0; }
  .row { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
  .card { border: 1px solid #e5e7eb; border-radius: 12px; padding: 16px; box-shadow: 0 2px 6px rgba(0,0,0,.05); background: #fff; margin-bottom:16px; }
  .muted { color: #6b7280; font-size: 12px; }
  #brandNotice{ font-size: 14px; }
  table { border-collapse: collapse; width: 100%; }
  th, td { border: 1px solid #e5e7eb; padding: 8px; font-size: 13px; vertical-align: top; }
  th { background: #f9fafb; position: sticky; top: 0; z-index: 1; }
  .sticky { max-height: 440px; overflow: auto; }
  :root { --btn-rgb: 34, 48, 85; }
  .btn { display: inline-block; padding: 10px 14px; border-radius: 8px; background: rgb(var(--btn-rgb)); color: #fff; cursor: pointer; border: none; }
  .btn.secondary { background: rgb(var(--btn-rgb)); color: #fff; }
  .btn.ghost { background: rgb(var(--btn-rgb)); color: #fff; }
  .btn:disabled { opacity: .5; cursor: not-allowed; }
  input[type="text"], select { padding: 8px; border: 1px solid #d1d5db; border-radius: 8px; }
  .mono { font-family: inherit; }
  .status { white-space: pre-wrap; font-size: 12px; background: #f8fafc; border:1px solid #e2e8f0; padding:8px; border-radius:8px; max-height:160px; overflow:auto;}
  .grid { display:grid; grid-template-columns: 1fr 1fr; gap:16px; }
  .pill { padding:4px 8px; border-radius:999px; background:#eef2ff; color:#3730a3; font-size:12px; }

  /* ===== Missing-label UX ===== */
  .flag-missing { background:#fff7ed; }
  .badge-missing { display:inline-block; padding:2px 6px; border-radius:999px; font-size:11px; background:#f97316; color:#fff; }
  .missing-editor { display:flex; flex-wrap:wrap; gap:6px; margin-top:6px; }
  .missing-editor input { width:96px; font-size:12px; padding:6px; }
  .missing-editor label > .muted { white-space: nowrap; overflow-wrap: normal; word-break: keep-all; }
  .missing-editor label { white-space: nowrap; }

  /* ===== Small UI helpers ===== */
  .subsec-title{font-size:15px;font-weight:600;margin:12px 0 6px;}
  .smallline{font-size:12px;color:#666; white-space:nowrap;}
  .row-compact label{margin-right:10px;}
  .smallcheck label{font-size:12px;}
  .soft-hr{height:1px;border:0;background:#e5e7eb;margin:10px 0;}
  .smalllabels label,.smalllabels input{font-size:12px;}
  .row.smalllabels,
  .row.row-compact.smalllabels{ display:inline-flex; flex-wrap:nowrap; align-items:center; gap:10px; }
  .row.smalllabels label,
  .row.row-compact.smalllabels label{ white-space:nowrap; }
  .tk-inline { display:flex; gap:10px; align-items:center; flex-wrap:nowrap; }
@media (max-width: 900px){
  .row.smalllabels,
  .row.row-compact.smalllabels{ flex-wrap:wrap; }
}

  /* ===== Summary table column sizing ===== */
  :root {
    --col-num: 56px;     /* ë²ˆí˜¸ ì—´ */
    --col-type: 160px;   /* ì‘ë‹µë°©ì‹ ì—´ */
    --col-index: 230px;  /* ë¬¸í•­ ì¸ë±ìŠ¤ ì—´ */
    --col-stem: 24%;  /* ì§ˆë¬¸ ì›ë³¸ ì—´ í­ ì œì–´(%ë¡œ) */
  }
  #summaryTable { table-layout: fixed; }
  #summaryTable th,
  #summaryTable td { overflow-wrap: anywhere; word-break: break-word; }
  #summaryTable td input[type="text"] {
    width: 100%;
    box-sizing: border-box;
  }
  #summaryTable th:first-child,
  #summaryTable td:first-child {
    text-align: center;
  }

</style>
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
</head>
<body>
<h1>ğŸ˜µ Raw Data Parser</h1>
<p class="muted">í‹¸ë¦¬ì–¸ì—ì„œ ë‹¤ìš´ë¡œë“œí•œ Raw Data ì—…ë¡œë“œí•´ ì „ë°˜ì ì¸ ì„¤ë¬¸ êµ¬ì¡°ë¥¼ í™•ì¸ â†’ ë¬¸í•­ ë¦¬ìŠ¤íŠ¸(To-Know) íŒŒì¼ì„ ì—…ë°ì´íŠ¸í•˜ê±°ë‚˜, AIë¥¼ í†µí•´ ë¬¸í•­ë³„ ì¸ë±ìŠ¤ ì²˜ë¦¬ â†’ ì‚¬ìš©ìê°€ ìë™ ì²˜ë¦¬ëœ ì‘ë‹µë°©ì‹ ë° ì¸ë±ìŠ¤ë¥¼ í™•ì¸/ìˆ˜ì • â†’ í—¤ë”ê°€ ë³€ê²½ëœ XLSX íŒŒì¼ì„ ë‹¤ìš´ë¡œë“œ</p>

<div class="grid">
  <!-- ===== Section 1: Raw íŒŒì¼ ì—…ë¡œë“œ & êµ¬ì¡° ì¸ì‹ ===== -->
  <div class="card">
    <h3>1) Raw Data ì—…ë¡œë“œ</h3>
    <div class="row">
      <input type="file" id="rawFile" accept=".xlsx"/>
      <select id="rawSheet" disabled></select>
      <button class="btn" id="parseRawBtn" disabled>ì„¤ë¬¸ êµ¬ì¡° í™•ì¸</button>
    </div>
    <p class="muted">â€» í—¤ë”ëŠ” 1í–‰=ì§ˆë¬¸ë¬¸, 2í–‰=ë³€ìˆ˜ëª…([0,1]); ì²« ì…€(0,0)ì€ ë¹„ì–´ë„ ì •ìƒ.</p>
    <div class="status" id="rawLog"></div>
    <div class="row" style="margin-top:8px;">
      <span class="pill">A~D ì‚­ì œ</span>
      <span class="pill">E=ì„±ë³„ F=ì—°ë ¹(1ì„¸ë‹¨ìœ„) G=ì—°ë ¹(10ì„¸ë‹¨ìœ„) H=ì§€ì—­</span>
    </div>
  </div>

  <!-- ===== Section 2: To-Know ì—…ë¡œë“œ & ì¸ë±ìŠ¤ ë§µ ìƒì„± ===== -->
  <div class="card">
    <h3>2) ë¬¸í•­ë³„ ì¸ë±ìŠ¤ ìƒì„±</h3>
    <h5 class="subsec-title">ë¬¸í•­ ë¦¬ìŠ¤íŠ¸(To-Know) íŒŒì¼ì„ ì—…ë¡œë“œí•´ ì¸ë±ìŠ¤ ìƒì„±</h5>
    <div class="row">
      <input type="file" id="tkFile" accept=".xlsx"/>
      <select id="tkSheet" disabled></select>
    </div>
    <div class="tk-inline">
      <div class="row smalllabels" style="margin-top:8px; gap:8px;">
        <label style="display:none;">í—¤ë” í–‰: <input type="text" id="tkHeaderRow" placeholder="ì˜ˆ: 2" style="width:90px"/></label>
        <label>êµ¬ë¶„ ì—´: <input type="text" id="tkGroupCol1" placeholder="ì˜ˆ: B" style="width:100px"/></label>
        <label>í•˜ìœ„ êµ¬ë¶„ ì—´: <input type="text" id="tkGroupCol2" placeholder="ì˜ˆ: C" style="width:100px"/></label>
        <label>No. ì—´: <input type="text" id="tkNoCol" placeholder="ì˜ˆ: D" style="width:100px"/></label>
        <label>ë¬¸í•­ ì—´: <input type="text" id="tkItemCol" placeholder="ì˜ˆ: E" style="width:100px"/></label>
      </div>
    </div>
    <div id="tkDetectSummary" class="smallline" style="margin-top:4px;"></div>
    <div class="row" style="margin-top:6px;">
      <button class="btn secondary" id="buildMapBtn" disabled>ì¸ë±ìŠ¤ ì±„ìš°ê¸°</button>
    </div>
    <div class="row smallcheck" style="margin-top:8px;">
      <label><input type="checkbox" id="useGroupPref" checked/> ì¸ë±ìŠ¤ì— 'êµ¬ë¶„' í¬í•¨</label>
      <label><input type="checkbox" id="useSubLabel"/> ì¸ë±ìŠ¤ì— 'êµ¬ë¶„'ê³¼ 'í•˜ìœ„ êµ¬ë¶„' í¬í•¨</label>
    </div>
    <hr class="soft-hr">
    <h5 class="subsec-title" style="margin-top:10px;">AIë¥¼ í†µí•´ ì¸ë±ìŠ¤ ìƒì„±</h5>
    <div class="row" style="margin-top:6px;">
      <button class="btn secondary" id="aiNameBtn" disabled>AIë¡œ ë¹„ì–´ìˆëŠ” ì¸ë±ìŠ¤ ì±„ìš°ê¸°</button>
    </div>
    <div class="muted" id="brandNotice" style="margin-top:4px;">
      â€» ê°œì¸ API Keyë¥¼ ì‚¬ìš©í•˜ê³  ìˆìœ¼ë¯€ë¡œ ë¸Œëœë”©1íŒ€ ì™¸ë¶€ ê³µìœ ë¥¼ ì ˆëŒ€ ê¸ˆí•¨
    </div>
    <div class="status" id="tkLog"></div>
  </div>
</div>

<!-- ===== Section 3: ìš”ì•½ í…Œì´ë¸” ===== -->
<div class="card">
  <h3>3) ì„¤ë¬¸ êµ¬ì¡° í™•ì¸ ê²°ê³¼</h3>
  <div class="sticky">
    <table id="summaryTable">
      <colgroup>
        <col style="width: var(--col-num);" />
        <col style="width: var(--col-stem);" />
        <col style="width: var(--col-type);" />
        <col style="width: var(--col-index);" />
        <col style="width: calc(100% - (var(--col-num) + var(--col-type) + var(--col-index)) - var(--col-stem));" />
      </colgroup>
      <thead>
        <tr>
          <th>ë²ˆí˜¸</th>
          <th>ì§ˆë¬¸ ì›ë³¸</th>
          <th>ì‘ë‹µë°©ì‹</th>
          <th>ë¬¸í•­ ì¸ë±ìŠ¤</th>
          <th>ë³´ê¸°</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>
</div>

<!-- ===== Section 4: ë‹¤ìš´ë¡œë“œ ì˜µì…˜ & ì‹¤í–‰ ===== -->
<div class="card">
  <h3>4) í—¤ë” ë³€ê²½ í›„ íŒŒì¼ ë‹¤ìš´ë¡œë“œ</h3>
  <div class="row" style="align-items:center; gap:12px;">
    <label><input type="checkbox" id="optCodeOnly"/> ì½”ë“œì—´ë§Œ ì¶”ì¶œ</label>
    <label><input type="checkbox" id="optTextOnly"/> í…ìŠ¤íŠ¸ì—´ë§Œ ì¶”ì¶œ</label>
    <button class="btn secondary" id="applyBtn" disabled>í—¤ë” ë³€ê²½ & XLSX ë‹¤ìš´ë¡œë“œ</button>
  </div>
</div>

<script>
/* ===== Feature Flags (ì¼œê¸°/ë„ê¸°) =====
   - useProxy: í”„ë¡ì‹œ ê²½ìœ  ON/OFF (ê¸°ë³¸ OFF â†’ ê¸°ì¡´ ë™ì‘ ìœ ì§€)
   - enumsCentralized: ë¬¸ìì—´ ìƒìˆ˜ ì¤‘ì•™ê´€ë¦¬ (í‘œí˜„ë§Œ í†µì¼, ë™ì‘ ë™ì¼)
*/
const FEATURE_FLAGS = {
  useProxy: true,
  enumsCentralized: true
};

/* ===== Centralized Constants ===== */
const RTYPE = Object.freeze({
  SINGLE: "ë‹¨ì¼ì‘ë‹µ",
  MULTI: "ì¤‘ë³µì‘ë‹µ",
  RANK: "ìˆœìœ„ì‘ë‹µ",
  MATRIX: "ë¦¬ì»¤íŠ¸ì²™ë„(Matrix)",
  LIKERT: "ë¦¬ì»¤íŠ¸ì²™ë„(ë‹¨ì¼)",
  OPEN: "ì˜¤í”ˆì‘ë‹µ",
  UNKNOWN: "ëª¨ë¥´ê² ìŒ"
});
const SPECIAL = Object.freeze({ ETC: 99, NONE: 100 });

/* ===== OpenAI ì‚¬ìš©ì„ ìœ„í•œ í”„ë¡ì‹œ ì„¤ì • ===== */
const AI_PROXY_PATH = "https://branding1-team-server.vercel.app/api/ai-index";
const TEAM_TOKEN = "Branding1team_2025";

/* ===== OpenAI API KEY ì§ì ‘ ì„¤ì • ===== */
// const OPENAI_API_KEY = "sk-(ê°œì¸ í‚¤)";
// const OPENAI_MODEL   = "gpt-4.1";

/* ===== App State ===== */
let rawWB, rawWS, rawAOA;
let rawColumns=[], rawRows=[];
let rawColsByQ = {};
let summary=[];                  // ìš”ì•½í‘œ ë°ì´í„°
let tkWB, tkWS, tkAOA;
let tkMap = {};                  // To-Know ê¸°ë°˜ ì¸ë±ìŠ¤
const RAW_HEADER_ROWS = [0,1];
const manualOptionLabels = {};   // â˜… ì‚¬ìš©ìê°€ ì±„ìš´ 'ë¼ë²¨ ì—†ìŒ' ë³´ì • { Q: { n: "ë¼ë²¨" } }

/* ===== Log Helper ===== */
const rawLog = document.getElementById('rawLog');
const tkLog  = document.getElementById('tkLog');
function log(el,msg){ console.log(msg); el.textContent += msg + "\n"; el.scrollTop = el.scrollHeight; }

/* ===== Utilities: Excel index/name, arrays, text ===== */
function colNameToIdx(name){
  if(!name) return null;
  name = name.trim().toUpperCase();
  let n=0;
  for(let i=0;i<name.length;i++){
    const c = name.charCodeAt(i);
    if(c<65 || c>90) return null;
    n = n*26 + (c-64);
  }
  return n-1;
}
function idxToColName(idx){
  let s=""; idx++;
  while(idx>0){ const m=(idx-1)%26; s=String.fromCharCode(65+m)+s; idx=Math.floor((idx-1)/26); }
  return s;
}
function safeAOA(ws){
  let a = XLSX.utils.sheet_to_json(ws, {header:1, raw:true});
  const max = Math.max(...a.map(r=>Array.isArray(r)?r.length:0));
  a = a.map(r=>{
    const row = Array.isArray(r)? r.slice() : [];
    if(row.length<max) row.length=max;
    return row.map(v=> (v===undefined? "": v));
  });
  return a;
}
function mode(arr){
  const c=new Map();
  arr.forEach(v=>{ c.set(v,(c.get(v)||0)+1); });
  let best=null,bc=-1;
  for(const [k,v] of c.entries()){ if(v>bc){bc=v;best=k;} }
  return best;
}
function extractQnumFromQtext(qtext){
  if(typeof qtext!=="string") return null;
  const m = qtext.match(/^\s*Q\s*(\d+)\./);
  return m ? `Q${m[1]}` : null;
}
function extractQnumFromVar(v){
  if(typeof v!=="string") return null;
  const m = v.match(/(Q\d+)/);
  return m ? m[1] : null;
}
function toStr(v){ return String(v == null ? "" : v).trim(); }
function trim(s){ return String(s==null ? "" : s).trim(); }
function hasAnyTextPresent(varTextObj){
  const col = varTextObj.colIndex;
  for (const r of rawRows){ if (toStr(r?.[col])!=="") return true; }
  return false;
}
function isOpenByAllBlankBase(varCodeObj){
  const colC = varCodeObj.colIndex;
  for (const r of rawRows){ if (toStr(r?.[colC]) !== "") return false; }
  return true;
}
function isLikertCodeRange(varCodeObj){
  const colC = varCodeObj.colIndex;
  const codeVals = [];
  for (const r of rawRows){ const s = toStr(r?.[colC]); if (s !== "") codeVals.push(s); }
  if (!codeVals.length) return false;
  const nums = new Set(codeVals.map(Number).filter(n=>!Number.isNaN(n)));
  const set5 = [1,2,3,4,5], set7 = [1,2,3,4,5,6,7];
  const ok5 = Array.from(nums).every(x => set5.includes(x));
  const ok7 = Array.from(nums).every(x => set7.includes(x));
  return ok5 || ok7;
}
function hasAnyEllipsisText(varTextObj){
  const colT = varTextObj.colIndex;
  for (const r of rawRows){ if (toStr(r?.[colT]) === '...') return true; }
  return false;
}
function escapeHtml(str){
  return String(str).replace(/[&<>"]/g,(c)=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c]) );
}
function makeIndexNameMinimal(q, qtext){
  let stem = (typeof qtext === "string" ? qtext : "").replace(/^\s*Q\s*\d+\.\s*/, "").trim();
  if (/ì—°ìƒ|ë– ì˜¤ë¥´/.test(stem)) {
    if (/ë¸Œëœë“œ/.test(stem)) return "ë¸Œëœë“œì—°ìƒ";
    if (/ì†ì„±|ì´ë¯¸ì§€/.test(stem)) return "ì†ì„±ì—°ìƒ";
    return "ì—°ìƒ";
  }
  if (/í˜¸ê°/.test(stem)) return "í˜¸ê°ë„";
  if (/ì‹ ë¢°/.test(stem)) return "ì‹ ë¢°ë„";
  if (/ë§Œì¡±/.test(stem)) return "ë§Œì¡±ë„";
  if (/ì˜í–¥/.test(stem)) return "ì´ìš©ì˜í–¥";
  if (/ì¸ì§€|ì•Œê³ /.test(stem)) return "ì¸ì§€";
  return stem.slice(0, 20) || `${q}_ì¸ë±ìŠ¤`;
}
function getSheetStartCol(ws){
  try {
    const ref = ws && ws['!ref'] ? ws['!ref'] : 'A1:A1';
    return XLSX.utils.decode_range(ref).s.c | 0;
  } catch(e){ return 0; }
}
function makeRegExp(qVar, pattern){
  const escaped = qVar.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  return new RegExp('^' + escaped + pattern);
}
function sortNumericKeys(obj){
  return Object.keys(obj).sort((a,b)=>Number(a)-Number(b));
}
function loadExcelFile(file, onSuccess, onError){
  const rd = new FileReader();
  rd.onload = ev=>{
    try{
      const wb = XLSX.read(new Uint8Array(ev.target.result), {type:'array'});
      onSuccess(wb);
    }catch(err){
      onError(err);
    }
  };
  rd.readAsArrayBuffer(file);
}
function populateSheetSelect(workbook, selectElement, buttonElement){
  selectElement.innerHTML="";
  workbook.SheetNames.forEach(n=>{
    const o=document.createElement('option'); o.value=n; o.textContent=n; selectElement.appendChild(o);
  });
  selectElement.disabled=false;
  if(buttonElement) buttonElement.disabled=false;
}

/* ===== Raw íŒŒì¼ ì—…ë¡œë“œ ì²˜ë¦¬ ===== */
const rawFile = document.getElementById('rawFile');
const rawSheetSel = document.getElementById('rawSheet');
const parseRawBtn = document.getElementById('parseRawBtn');
const applyBtn = document.getElementById('applyBtn');

rawFile.addEventListener('change', e=>{
  rawLog.textContent="";
  const f = e.target.files[0];
  if(!f){ parseRawBtn.disabled=true; return; }
  loadExcelFile(f, 
    (wb)=>{
      rawWB = wb;
      populateSheetSelect(rawWB, rawSheetSel, parseRawBtn);
      log(rawLog, "Raw ì›Œí¬ë¶ ë¡œë“œ: " + rawWB.SheetNames.join(", "));
    },
    (err)=>{
      alert("Raw íŒŒì‹± ì‹¤íŒ¨: " + err.message);
      log(rawLog, err.stack);
    }
  );
});

/* ===== To-Know ì—…ë¡œë“œ ì²˜ë¦¬ ===== */
const tkFile = document.getElementById('tkFile');
const tkSheetSel = document.getElementById('tkSheet');
const tkHeaderRowInp = document.getElementById('tkHeaderRow');
const tkNoColInp = document.getElementById('tkNoCol');
const tkItemColInp = document.getElementById('tkItemCol');
const tkGroupCol1 = document.getElementById('tkGroupCol1');
const tkGroupCol2 = document.getElementById('tkGroupCol2');
const tkDetectSummary = document.getElementById('tkDetectSummary');
const buildMapBtn = document.getElementById('buildMapBtn');
const useGroupPref = document.getElementById('useGroupPref');
const useSubLabel  = document.getElementById('useSubLabel');

try{ tkSheetSel.addEventListener('change', runTkAutoDetect); }catch(e){}
[tkGroupCol1, tkGroupCol2].forEach(el=>{ el?.addEventListener('input', updateGroupCheckboxState); });

tkFile.addEventListener('change', e=>{
  tkLog.textContent="";
  const f = e.target.files[0];
  if(!f){ buildMapBtn.disabled=true; return; }
  loadExcelFile(f,
    (wb)=>{
      tkWB = wb;
      populateSheetSelect(tkWB, tkSheetSel, buildMapBtn);
      log(tkLog, "To-Know ì›Œí¬ë¶ ë¡œë“œ: " + tkWB.SheetNames.join(", "));
      try{ runTkAutoDetect(); }catch(e){}
    },
    (err)=>{
      alert("To-Know íŒŒì‹± ì‹¤íŒ¨: " + err.message);
      log(tkLog, err.stack);
    }
  );
});

/* ===== To-Know í—¤ë” ë™ì˜ì–´ ===== */
const TKN_SYNONYMS = {
  no:       ["No.", "NO", "no", "ë²ˆí˜¸", "ë¬¸í•­ë²ˆí˜¸"],
  item:     ["ë¬¸í•­", "í•­ëª©", "ë¬¸í•­ëª…", "Question", "ì§ˆë¬¸"],
  group:    ["êµ¬ë¶„", "íŒŒíŠ¸", "ë¶„ë¥˜", "Category", "ì¹´í…Œê³ ë¦¬"],
  subgroup: ["í•˜ìœ„êµ¬ë¶„", "í•˜ìœ„ êµ¬ë¶„", "ì„œë¸Œêµ¬ë¶„", "Sub"]
};

/* ===== To-Know ìë™ ê°ì§€ ===== */
function runTkAutoDetect(){
  try{
    const name = tkSheetSel.value || tkWB.SheetNames[0];
    tkWS = tkWB.Sheets[name];
    tkAOA = safeAOA(tkWS);

    let headerRowIdx = null, noColIdx=null, itemColIdx=null, groupColIdx=null, subgroupColIdx=null;
    const scanRows = Math.min(10, tkAOA.length);

    const matchOne = (row, cands) => {
      let idx = row.findIndex(x => cands.some(s => String(x||"").trim().toLowerCase() === String(s).toLowerCase()));
      if (idx >= 0) return idx;
      idx = row.findIndex(x => cands.some(s => String(x||"").trim().toLowerCase().includes(String(s).toLowerCase())));
      return idx >= 0 ? idx : -1;
    };

    // 1) í—¤ë” í–‰ ì°¾ê¸°: No. + ë¬¸í•­ì´ ìˆëŠ” í–‰
    for(let r=0; r<scanRows; r++){
      const row = tkAOA[r].map(v=> String(v||"").trim());
      const noIdx   = matchOne(row, TKN_SYNONYMS.no);
      const itemIdx = matchOne(row, TKN_SYNONYMS.item);
      if (noIdx >= 0 && itemIdx >= 0){
        headerRowIdx = r;
        noColIdx     = noIdx;
        itemColIdx   = itemIdx;
        
        // â˜… êµ¬ë¶„ ì—´ ì°¾ê¸°: "êµ¬ë¶„" í—¤ë”ë¥¼ ê°€ì§„ ëª¨ë“  ì—´ ì°¾ê¸°
        const groupIndices = [];
        row.forEach((cellVal, idx) => {
          const val = String(cellVal || "").trim();
          const isGroupHeader = TKN_SYNONYMS.group.some(s => 
            val.toLowerCase() === String(s).toLowerCase() ||
            val.toLowerCase().includes(String(s).toLowerCase())
          );
          if (isGroupHeader) {
            groupIndices.push(idx);
          }
        });
        
        // â˜… "êµ¬ë¶„" í—¤ë”ê°€ 2ê°œ ì´ìƒ ì—°ì†ìœ¼ë¡œ ìˆëŠ” ê²½ìš° ì²˜ë¦¬
        if (groupIndices.length >= 2) {
          // ì—°ì†ëœ "êµ¬ë¶„" í—¤ë”ì¸ì§€ í™•ì¸
          let consecutive = true;
          for (let i = 1; i < groupIndices.length; i++) {
            if (groupIndices[i] !== groupIndices[i-1] + 1) {
              consecutive = false;
              break;
            }
          }
          
          if (consecutive) {
            // ë³‘í•©ì…€ ì¼€ì´ìŠ¤: ì²« ë²ˆì§¸ = êµ¬ë¶„, ë‘ ë²ˆì§¸ = í•˜ìœ„ êµ¬ë¶„
            groupColIdx = groupIndices[0];
            subgroupColIdx = groupIndices[1];
            log(tkLog, `ë³‘í•©ëœ "êµ¬ë¶„" í—¤ë” ê°ì§€: ${idxToColName(groupIndices[0])}-${idxToColName(groupIndices[groupIndices.length-1])}ì—´ â†’ ì²«ë²ˆì§¸=êµ¬ë¶„, ë‘ë²ˆì§¸=í•˜ìœ„êµ¬ë¶„`);
          } else {
            // ë¹„ì—°ì†: ì²« ë²ˆì§¸ë§Œ êµ¬ë¶„ìœ¼ë¡œ ì‚¬ìš©
            groupColIdx = groupIndices[0];
            subgroupColIdx = matchOne(row, TKN_SYNONYMS.subgroup);
          }
        } else if (groupIndices.length === 1) {
          // "êµ¬ë¶„" í—¤ë”ê°€ 1ê°œë§Œ ìˆìŒ
          groupColIdx = groupIndices[0];
          subgroupColIdx = matchOne(row, TKN_SYNONYMS.subgroup);
        } else {
          // "êµ¬ë¶„" í—¤ë”ê°€ ì—†ìŒ
          groupColIdx = matchOne(row, TKN_SYNONYMS.group);
          subgroupColIdx = matchOne(row, TKN_SYNONYMS.subgroup);
        }
        
        break;
      }
    }

    if(headerRowIdx===null){
      const hdrWrap = tkHeaderRowInp ? (tkHeaderRowInp.closest('label') || tkHeaderRowInp.parentElement) : null;
      if (hdrWrap) hdrWrap.style.display = '';
      if (tkDetectSummary){
        tkDetectSummary.textContent = "í—¤ë” í–‰ì„ ìë™ìœ¼ë¡œ ê°ì§€í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ì—‘ì…€ì—ì„œ 'No.'ì™€ 'ë¬¸í•­' í—¤ë”ê°€ í•œ ì¤„ì— ìˆê³  ë³‘í•©ì…€ì´ í•´ì œë˜ì–´ ìˆëŠ”ì§€ í™•ì¸í•œ ë’¤, í•„ìš”í•˜ë©´ ìœ„ 'í—¤ë” í–‰'ì— ì—‘ì…€ ê¸°ì¤€ í–‰ ë²ˆí˜¸ë¥¼ ì§ì ‘ ì…ë ¥í•˜ì„¸ìš”.";
      }
      alert("í—¤ë” í–‰ì„ ìë™ìœ¼ë¡œ ê°ì§€í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.\n- 'No.'ì™€ 'ë¬¸í•­' í—¤ë”ê°€ ìˆëŠ”ì§€ í™•ì¸\n- í–‰/ì—´ ë³‘í•© í•´ì œ í›„ ì €ì¥\n- í—¤ë”ê°€ ì•„ë˜ìª½ì— ìˆìœ¼ë©´ 'í—¤ë” í–‰'ì— ì—‘ì…€ ê¸°ì¤€ í–‰ ë²ˆí˜¸ë¥¼ ì§ì ‘ ì…ë ¥\nìˆ˜ì • í›„ íŒŒì¼ì„ ë‹¤ì‹œ ì„ íƒí•˜ê±°ë‚˜ 'ì¸ë±ìŠ¤ ì±„ìš°ê¸°'ë¥¼ ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”.");
      log(tkLog, "ìë™ ê°ì§€ ì‹¤íŒ¨: í—¤ë”ë¥¼ ì°¾ì§€ ëª»í•¨(ì‚¬ìš©ì ì•ˆë‚´ í‘œì‹œ).");
      return;
    }

    // 2) â˜… í•˜ìœ„ êµ¬ë¶„ ì—´ ì¶”ê°€ ê°ì§€: í—¤ë”ê°€ ë¹„ì–´ìˆì§€ë§Œ êµ¬ë¶„ê³¼ No. ì‚¬ì´ì— ë°ì´í„°ê°€ ìˆëŠ” ì—´
    // (ë³‘í•©ì…€ë¡œ ì´ë¯¸ ê°ì§€ë˜ì§€ ì•Šì€ ê²½ìš°ì—ë§Œ)
    if ((subgroupColIdx === null || subgroupColIdx === -1) && groupColIdx !== null && groupColIdx >= 0 && noColIdx >= 0) {
      // êµ¬ë¶„ê³¼ No. ì‚¬ì´ì˜ ì—´ë“¤ì„ ê²€ì‚¬
      for (let col = groupColIdx + 1; col < noColIdx; col++) {
        // í—¤ë” í–‰ì€ ë¹„ì–´ìˆê±°ë‚˜ "êµ¬ë¶„"ì´ì§€ë§Œ, ë°ì´í„° í–‰ì— ê°’ì´ ìˆëŠ”ì§€ í™•ì¸
        const headerVal = String(tkAOA[headerRowIdx][col] || "").trim();
        
        // ì´ë¯¸ ë‹¤ë¥¸ ìš©ë„ë¡œ ì¸ì‹ëœ ì—´ì€ ê±´ë„ˆë›°ê¸°
        if (col === groupColIdx || col === noColIdx || col === itemColIdx) continue;
        
        // ë‹¤ìŒ ëª‡ í–‰ì„ ê²€ì‚¬í•˜ì—¬ ë°ì´í„°ê°€ ìˆëŠ”ì§€ í™•ì¸
        let hasData = false;
        for (let r = headerRowIdx + 1; r < Math.min(headerRowIdx + 20, tkAOA.length); r++) {
          const cellVal = String(tkAOA[r][col] || "").trim();
          if (cellVal !== "" && cellVal !== "0") {
            hasData = true;
            break;
          }
        }
        
        if (hasData) {
          subgroupColIdx = col;
          log(tkLog, `í•˜ìœ„ êµ¬ë¶„ ì—´ ë°œê²¬: ${idxToColName(col)}ì—´ì— ë°ì´í„° ì¡´ì¬ (í—¤ë”: "${headerVal}")`);
          break;
        }
      }
    }

    const startCol = getSheetStartCol(tkWS);

    tkHeaderRowInp.value = String(headerRowIdx+1);
    const hdrWrap = tkHeaderRowInp ? (tkHeaderRowInp.closest('label') || tkHeaderRowInp.parentElement) : null;
    if (hdrWrap) hdrWrap.style.display = 'none';

    tkNoColInp.value   = idxToColName(noColIdx   + startCol);
    tkItemColInp.value = idxToColName(itemColIdx + startCol);

    const g1 = (groupColIdx !== null && groupColIdx >= 0) ? idxToColName(groupColIdx + startCol) : "";
    const g2 = (subgroupColIdx !== null && subgroupColIdx >= 0) ? idxToColName(subgroupColIdx + startCol) : "";
    if (tkGroupCol1) tkGroupCol1.value = g1;
    if (tkGroupCol2) tkGroupCol2.value = g2;

    const hdr = tkAOA[headerRowIdx] || [];
    const g1T = g1 ? `${g1}("${String(hdr[groupColIdx] || "").trim()}")` : "(ì—†ìŒ)";
    const g2T = g2 ? `${g2}("${String(hdr[subgroupColIdx] || "ë¹ˆí—¤ë”-ë°ì´í„°ìˆìŒ").trim()}")` : "(ì—†ìŒ)";
    const noT = `${idxToColName(noColIdx+startCol)}("${hdr[noColIdx]}")`;
    const itT = `${idxToColName(itemColIdx+startCol)}("${hdr[itemColIdx]}")`;
    if (tkDetectSummary){
      tkDetectSummary.textContent = `êµ¬ë¶„ ì—´: ${g1T} â€¢ í•˜ìœ„ êµ¬ë¶„ ì—´: ${g2T} â€¢ No. ì—´: ${noT} â€¢ ë¬¸í•­ ì—´: ${itT}`;
    }

    updateGroupCheckboxState();
    log(tkLog, `ê°ì§€ë¨ â†’ êµ¬ë¶„: ${g1T}, í•˜ìœ„ êµ¬ë¶„: ${g2T} | No.: ${noT} | ë¬¸í•­: ${itT}`);
  }catch(err){
    log(tkLog, "ìë™ ê°ì§€ ì˜¤ë¥˜: " + err.message);
  }
}


/* ===== To-Know ì˜µì…˜ ìƒíƒœ ë™ê¸°í™” ===== */
function updateGroupCheckboxState(){
  try{
    const hasGroup = !!(tkGroupCol1 && tkGroupCol1.value.trim());
    const hasSub   = !!(tkGroupCol2 && tkGroupCol2.value.trim());
    if(!hasGroup){
      if(useGroupPref){ useGroupPref.checked=false; useGroupPref.disabled=true; }
      if(useSubLabel){  useSubLabel.checked=false;  useSubLabel.disabled=true;  }
      return;
    }else{
      if(useGroupPref) useGroupPref.disabled=false;
      if(useSubLabel)  useSubLabel.disabled = !hasSub;
      if(!hasSub && useSubLabel) useSubLabel.checked=false;
    }
    // â˜… ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆëŠ” DOMContentLoadedì—ì„œ ì´ë¯¸ ë“±ë¡ë˜ì—ˆìœ¼ë¯€ë¡œ ì—¬ê¸°ì„œëŠ” ë¶ˆí•„ìš”
  }catch(e){}
}

/* ===== To-Know ì¸ë±ìŠ¤ ë§µ ìƒì„± ===== */
buildMapBtn.addEventListener('click', ()=>{
  try{
    const name = tkSheetSel.value || tkWB.SheetNames[0];
    tkWS = tkWB.Sheets[name];
    tkAOA = safeAOA(tkWS);

    const header1 = Number(tkHeaderRowInp.value) || 2;
    const headIdx = header1 - 1;

    const startCol = getSheetStartCol(tkWS);

    const noCol   = colNameToIdx((tkNoColInp.value   || "D").trim()) - startCol;
    const itemCol = colNameToIdx((tkItemColInp.value || "E").trim()) - startCol;

    const g1 = colNameToIdx((tkGroupCol1?.value||"").trim());
    const g2 = colNameToIdx((tkGroupCol2?.value||"").trim());
    let groupCols = [g1, g2].map(x => (x==null? null : x - startCol)).filter(x=>x!==null);

    const hdr = tkAOA[headIdx] || [];
    const g1Lbl = groupCols[0] != null ? `${idxToColName(groupCols[0]+startCol)}=${hdr[groupCols[0]] || "(ë¹ˆí—¤ë”)"}` : "(ì—†ìŒ)";
    const g2Lbl = groupCols[1] != null ? `${idxToColName(groupCols[1]+startCol)}=${hdr[groupCols[1]] || "(ë¹ˆí—¤ë”)"}` : "(ì—†ìŒ)";
    log(tkLog, `ì„ íƒëœ í—¤ë” â†’ êµ¬ë¶„: ${g1Lbl} | í•˜ìœ„ êµ¬ë¶„: ${g2Lbl} | No.: ${idxToColName(noCol+startCol)}=${hdr[noCol]} | ë¬¸í•­: ${idxToColName(itemCol+startCol)}=${hdr[itemCol]}`);

    // â˜… êµ¬ë¶„/í•˜ìœ„êµ¬ë¶„ Forward Fill ì²˜ë¦¬
    // - êµ¬ë¶„ ì—´(groupCols[0]): ë¬´ì¡°ê±´ ì±„ìš°ê¸°
    // - í•˜ìœ„êµ¬ë¶„ ì—´(groupCols[1]): êµ¬ë¶„ì´ ë°”ë€Œë©´ ë¦¬ì…‹
    if (groupCols[0] != null) {
      forwardFillColumn(tkAOA, groupCols[0]); // êµ¬ë¶„ì€ ê·¸ëƒ¥ ì±„ìš°ê¸°
    }
    if (groupCols[1] != null) {
      forwardFillColumn(tkAOA, groupCols[1], groupCols[0]); // í•˜ìœ„êµ¬ë¶„ì€ êµ¬ë¶„ì´ ë°”ë€Œë©´ ë¦¬ì…‹
    }

    // â˜… No.=1ì¸ í–‰ ì°¾ê¸° (ë°ì´í„° ì‹œì‘ì  ë™ì  ê°ì§€)
    let dataStartRow = headIdx + 1;
    for (let r = headIdx + 1; r < Math.min(headIdx + 50, tkAOA.length); r++) {
      const noVal = tkAOA[r][noCol];
      if (Number(noVal) === 1) {
        dataStartRow = r;
        log(tkLog, `ë°ì´í„° ì‹œì‘ í–‰ ê°ì§€: ${dataStartRow + 1}í–‰ (No.=1 ë°œê²¬)`);
        break;
      }
    }

    // â˜… ìœ íš¨ì„± ê²€ì‚¬ - í•„ìˆ˜ ì—´ë§Œ ê²€ì‚¬í•˜ê³  ë‚˜ë¨¸ì§€ëŠ” ë¬´ì‹œ
    const errs = validateToKnow(tkAOA, dataStartRow - 1, noCol, itemCol, groupCols, dataStartRow);
    if (errs.length){
      alert("To-Know ìœ íš¨ì„± ê²€ì‚¬ ì˜¤ë¥˜:\n- " + errs.join("\n- "));
      log(tkLog, "ìœ íš¨ì„± ê²€ì‚¬ ì‹¤íŒ¨:\n" + errs.join("\n"));
      return;
    }

    const norm = (s)=> String(s ?? "").trim().replace(/\s+/g, " ").replace(/[\,\/\\\|\:\;]+/g, "_");
    tkMap = {};
    
    // â˜… dataStartRowë¶€í„° ì²˜ë¦¬
    for(let r=dataStartRow; r<tkAOA.length; r++){
      const noRaw = tkAOA[r][noCol];
      const item  = norm(tkAOA[r][itemCol]);
      const noNum = Number(noRaw);
      if(!Number.isFinite(noNum)) continue;
      const q = `Q${noNum}`;

      let prefixParts=[];
      
      // â˜… ì²´í¬ë°•ìŠ¤ ë¡œì§ (ë®¤í…ìŠ¤)
      // 1. "í•˜ìœ„êµ¬ë¶„" ì²´í¬ â†’ êµ¬ë¶„ + í•˜ìœ„êµ¬ë¶„
      // 2. "êµ¬ë¶„" ì²´í¬ â†’ êµ¬ë¶„ë§Œ
      // 3. ë‘˜ ë‹¤ í•´ì œ â†’ ë¬¸í•­ë§Œ
      if(useSubLabel.checked && groupCols[1] != null){
        // "í•˜ìœ„êµ¬ë¶„" ì²´í¬ë¨ â†’ êµ¬ë¶„ + í•˜ìœ„êµ¬ë¶„ ë‘˜ ë‹¤ í¬í•¨
        if (groupCols[0] != null){
          const v1 = norm(tkAOA[r][groupCols[0]]);
          if (v1) prefixParts.push(v1);
        }
        const v2 = norm(tkAOA[r][groupCols[1]]);
        if (v2) prefixParts.push(v2);
      } else if(useGroupPref.checked && groupCols[0] != null){
        // "êµ¬ë¶„"ë§Œ ì²´í¬ë¨ â†’ êµ¬ë¶„ë§Œ í¬í•¨
        const v1 = norm(tkAOA[r][groupCols[0]]);
        if (v1) prefixParts.push(v1);
      }
      // ë‘˜ ë‹¤ í•´ì œë©´ prefixPartsê°€ ë¹„ì–´ìˆìŒ â†’ ë¬¸í•­ë§Œ
      
      let indexText = "";
      if(prefixParts.length){
        indexText = prefixParts.join("_");
        if(item) indexText += "_" + item;
      }else{
        indexText = item || "";
      }
      tkMap[q] = indexText;
    }

    log(tkLog, `ì¸ë±ìŠ¤ ë§µ ìƒì„± ì™„ë£Œ (í•­ëª© ìˆ˜: ${Object.keys(tkMap).length})`);

    if(summary?.length){
      for(const row of summary){
        const key = row["Që²ˆí˜¸"];
        if(tkMap[key]) row["í•­ëª©ëª…(ì¸ë±ìŠ¤)"] = tkMap[key];
      }
      renderSummary();
    }
  }catch(err){
    alert("To-Know ì¸ë±ìŠ¤ ë§µ ìƒì„± ì˜¤ë¥˜: " + err.message);
    log(tkLog, err.stack);
  }
});


/* ===== To-Know ìœ íš¨ì„± ê²€ì‚¬ ===== */
function forwardFillColumn(rows, colIndex, resetColIndex){
  if (colIndex == null) return;
  let last = "";
  let lastResetValue = "";
  
  for (let i=0;i<rows.length;i++){
    const v = String(rows[i][colIndex] ?? "").trim();
    
    // â˜… resetColIndexê°€ ì§€ì •ë˜ì–´ ìˆìœ¼ë©´, í•´ë‹¹ ì—´ì˜ ê°’ì´ ë°”ë€” ë•Œ ë¦¬ì…‹
    if (resetColIndex != null) {
      const resetVal = String(rows[i][resetColIndex] ?? "").trim();
      if (resetVal !== "" && resetVal !== lastResetValue) {
        // êµ¬ë¶„ì´ ë°”ë€Œì—ˆìœ¼ë¯€ë¡œ í•˜ìœ„êµ¬ë¶„ ë¦¬ì…‹
        last = "";
        lastResetValue = resetVal;
      }
    }
    
    if (v !== "") {
      last = v;
    } else if (last !== "") {
      rows[i][colIndex] = last;
    }
  }
}
function validateToKnow(tkAOA, headIdx, noCol, itemCol, groupCols, dataStartRow){
  const errs = [];
  const seen = new Map();
  const nos  = [];
  
  // â˜… dataStartRowê°€ ì§€ì •ë˜ì§€ ì•Šìœ¼ë©´ headIdx+1 ì‚¬ìš©
  const startRow = dataStartRow !== undefined ? dataStartRow : (headIdx + 1);
  
  for(let r=startRow; r<tkAOA.length; r++){
    const row = tkAOA[r] || [];
    const noRaw = row[noCol];
    const item  = String(row[itemCol]||"").trim();
    const hasNo = (noRaw !== undefined && noRaw !== null && String(noRaw).trim()!=="");
    const noNum = Number(noRaw);

    // â˜… No.ë„ ì—†ê³  ë¬¸í•­ë„ ì—†ìœ¼ë©´ ë¹ˆ í–‰ìœ¼ë¡œ ê°„ì£¼í•˜ê³  ê±´ë„ˆë›°ê¸°
    if (!hasNo && item === "") continue;
    
    if (item === "") errs.push(`ë¬¸í•­ ì˜¤ë¥˜: ê³µë€ (í–‰ ${r+1})`);
    if (item !== "" && !hasNo) errs.push(`ì˜¤ë¥˜: ë¬¸í•­ì€ ìˆëŠ”ë° No. ì—†ìŒ (í–‰ ${r+1})`);
    const hasAnyGroup = groupCols.some(ci => String(row[ci]||"").trim()!=="");
    if (hasAnyGroup && item==="") errs.push(`ì˜¤ë¥˜: êµ¬ë¶„ë§Œ ìˆê³  ë¬¸í•­ ì—†ìŒ (í–‰ ${r+1})`);

    if (hasNo && Number.isFinite(noNum)) {
      nos.push(noNum);
      seen.set(noNum, (seen.get(noNum)||0)+1);
      // â˜… 50 ì œí•œ í•´ì œ (í° ë²ˆí˜¸ë„ í—ˆìš©)
    } else if (hasNo) {
      errs.push(`No. ì˜¤ë¥˜: ìˆ«ìê°€ ì•„ë‹˜ (í–‰ ${r+1})`);
    }
  }
  if (nos.length){
    const uniq = Array.from(new Set(nos)).sort((a,b)=>a-b);
    const max  = Math.max(...uniq);
    const min  = Math.min(...uniq);
    
    // â˜… ìµœì†Œê°’ë¶€í„° ìµœëŒ€ê°’ê¹Œì§€ ì—°ì†ì„± ê²€ì‚¬ (1ë¶€í„°ê°€ ì•„ë‹ ìˆ˜ ìˆìŒ)
    const expected = Array.from({length: max - min + 1}, (_,i)=> min + i);
    const missing  = expected.filter(x => !uniq.includes(x));
    for (const [k,c] of seen.entries()){ if (c>1) errs.push(`No. ì˜¤ë¥˜: ì¤‘ë³µ ë²ˆí˜¸ ${k}`); }
    if (missing.length) errs.push(`No. ì˜¤ë¥˜: ëˆ„ë½ ë²ˆí˜¸ ${missing.join(", ")}`);
  }
  return errs;
}

/* ===== Raw êµ¬ì¡° ì¸ì‹ & ìš”ì•½ ìƒì„± ===== */
parseRawBtn.addEventListener('click', ()=>{
  try{
    const name = rawSheetSel.value || rawWB.SheetNames[0];
    rawWS = rawWB.Sheets[name];
    rawAOA = safeAOA(rawWS);
    log(rawLog, `[${name}] ì›ë³¸: í–‰=${rawAOA.length}, ì²«í–‰ ì—´ìˆ˜=${(rawAOA[0]?rawAOA[0].length:0)}`);

    if(!rawAOA || rawAOA.length<=Math.max(...RAW_HEADER_ROWS)){
      alert("ì‹œíŠ¸ê°€ ë¹„ì—ˆê±°ë‚˜ í—¤ë”(1,2í–‰)ê°€ ì—†ìŠµë‹ˆë‹¤.");
      return;
    }

    // A~D ì œê±° â†’ ë©”íƒ€ 4ì—´ì„ 0~3 ì¸ë±ìŠ¤ë¡œ ê³ ì •
    rawAOA = rawAOA.map(row => row.slice(4));
    log(rawLog, "A~D ì—´ ì‚­ì œ ì ìš©.");

    // ë©”íƒ€ 4ì—´ ê°•ì œ í—¤ë” (E~H â†’ 0~3)
    const L0 = rawAOA[0] || [];
    const L1 = rawAOA[1] || [];
    const fixed = ["ì„±ë³„","ì—°ë ¹(1ì„¸ë‹¨ìœ„)","ì—°ë ¹(10ì„¸ë‹¨ìœ„)","ì§€ì—­"];
    for(let i=0;i<4;i++){ if(L0.length>i) L0[i]=fixed[i]; if(L1.length>i) L1[i]=""; }
    log(rawLog, "E~H ê°•ì œ í—¤ë” ì§€ì • ì™„ë£Œ: "+fixed.join(", "));

    // í—¤ë” í–‰ ë³´ì •
    const h0raw = rawAOA[0] || [];
    const h1raw = rawAOA[1] || [];
    const maxLen = Math.max(h0raw.length, h1raw.length);
    const h0 = Array.from({length:maxLen}, (_,i)=> String(h0raw[i] ?? ""));
    const h1 = Array.from({length:maxLen}, (_,i)=> String(h1raw[i] ?? ""));

    rawColumns = h0.map((qtext,i)=> ({ qtext, var:h1[i], colIndex:i }));
    rawRows = rawAOA.slice(Math.max(...RAW_HEADER_ROWS) + 1);

    // Që³„ ê·¸ë£¹í•‘
    rawColsByQ = {};
    for(const col of rawColumns){
      const q = extractQnumFromQtext(col.qtext) || extractQnumFromVar(col.var);
      if(!q) continue;
      (rawColsByQ[q] ||= []).push(col);
    }
    for(const q of Object.keys(rawColsByQ)){
      rawColsByQ[q] = rawColsByQ[q].filter(v=> v && typeof v.qtext==='string' && typeof v.var==='string');
      if(rawColsByQ[q].length===0) delete rawColsByQ[q];
    }

    // ìš”ì•½(ì‘ë‹µë°©ì‹/ë³´ê¸°/ì¸ë±ìŠ¤)
    summary = [];
    const sortedQs = Object.keys(rawColsByQ).sort((a,b)=>Number(a.slice(1))-Number(b.slice(1)));
    for(const q of sortedQs){
      const vars = rawColsByQ[q];
      const candidates = vars.map(v=>v.qtext).filter(s=> s && String(s).trim()!=="");
      const qtext = mode(candidates) || candidates[0] || "";
      const rtype = detectResponseType(qtext, vars);
      const options = buildOptionLabels(q, qtext, vars, rtype);
      const idx = tkMap[q] || "";
      summary.push({ "Që²ˆí˜¸":q, "ë¬¸í•­ë¬¸":qtext, "ì‘ë‹µë°©ì‹":rtype, "í•­ëª©ëª…(ì¸ë±ìŠ¤)":idx, "ë³´ê¸°(ìš”ì•½)":options });
    }

    renderSummary();
    applyBtn.disabled=false;
    const _btn=document.getElementById('aiNameBtn'); if(_btn) _btn.disabled=false;
    log(rawLog, "ì„¤ë¬¸ êµ¬ì¡° í™•ì¸ ì™„ë£Œ. (To-Know ë¯¸ì§€ì • ì‹œ ì¸ë±ìŠ¤ ì¹¸ì€ ë¹„ì–´ ìˆìŒ)");
  }catch(err){
    alert("êµ¬ì¡° ì¸ì‹ ì˜¤ë¥˜: " + err.message);
    log(rawLog, err.stack);
  }
});

/* ===== ì‘ë‹µìœ í˜• íŒì • ===== */
const SPECIAL_CODE_SET = new Set(["99","100"]);
function isSpecialCode(s){ return SPECIAL_CODE_SET.has(String(s).trim()); }
function hasRankKeyword(qtext){ return (typeof qtext === "string") && /(ìˆœìœ„|ëª‡\s*ìœ„|ìˆœì„œëŒ€ë¡œ|ìš°ì„ ìˆœìœ„|ë­í¬)/.test(qtext); }
function codesAreNumeric(varCodeObj){
  const col = varCodeObj.colIndex; let seen = false;
  for (const r of rawRows){
    const s = toStr(r?.[col]); if (s==="") continue;
    seen = true; if (!/^\d+$/.test(s)) return false;
  }
  return seen;
}
function detectResponseType(qtext, varsForQ){
  varsForQ = (varsForQ||[]).filter(v=> v && typeof v.var==='string');
  if(!varsForQ.length) return "ëª¨ë¥´ê² ìŒ";

  const qFromVar = varsForQ.map(v=>extractQnumFromVar(v.var)).find(Boolean) || "";
  const hasBaseCode = varsForQ.find(v=> v.var===qFromVar);
  const hasBaseText = varsForQ.find(v=> v.var===`${qFromVar}(TEXT)`);

  if (varsForQ.some(v => /^Q\d+_\d+\.\s*/.test(v.var))) return "ë¦¬ì»¤íŠ¸ì²™ë„(Matrix)";

  const codeColsByN = {};
  const textColsByN = {};
  for (const v of varsForQ) {
    let m = v.var.match(makeRegExp(qFromVar, '_(\\d+)$')); if (m) codeColsByN[m[1]] = v.colIndex;
    m = v.var.match(makeRegExp(qFromVar, '_(\\d+)\\(TEXT\\)$')); if (m) textColsByN[m[1]] = v.colIndex;
    m = v.var.match(makeRegExp(qFromVar, '_(\\d+)\\.\\s*.*?\\s*\\(TEXT\\)$')); if (m && textColsByN[m[1]] == null) textColsByN[m[1]] = v.colIndex;
  }
  const ns = sortNumericKeys({ ...codeColsByN, ...textColsByN });

  if (ns.length){
    let hasRankNumber = false;
    let isAllCodeEqualOwnN = true;
    for (const n of ns){
      const ccol = codeColsByN[n];
      if (ccol == null) continue;
      for (const r of rawRows){
        const s = toStr(r?.[ccol]);
        if (s==="") continue;
        if (/^\d+$/.test(s)){
          if (isSpecialCode(s)) { continue; }
          if (s !== String(n)) { hasRankNumber = true; isAllCodeEqualOwnN = false; }
        } else {
          isAllCodeEqualOwnN = false;
        }
      }
    }
    if (hasRankNumber) return "ìˆœìœ„ì‘ë‹µ";
    if (isAllCodeEqualOwnN) return "ì¤‘ë³µì‘ë‹µ";
    if (hasRankKeyword(qtext)) return "ìˆœìœ„ì‘ë‹µ";
    return "ì¤‘ë³µì‘ë‹µ";
  }

  if (hasBaseCode && hasBaseText){
    if (isOpenByAllBlankBase(hasBaseCode) && hasAnyTextPresent(hasBaseText)) return "ì˜¤í”ˆì‘ë‹µ";
    if (isLikertCodeRange(hasBaseCode) && hasAnyEllipsisText(hasBaseText)) return "ë¦¬ì»¤íŠ¸ì²™ë„(ë‹¨ì¼)";
    if (codesAreNumeric(hasBaseCode) && !hasAnyEllipsisText(hasBaseText)) return "ë‹¨ì¼ì‘ë‹µ";
    return "ë‹¨ì¼ì‘ë‹µ";
  }

  if (typeof qtext==="string" && /(ììœ ë¡­ê²Œ|ê¸°ì¬í•´ì£¼|ì‘ì„±í•´ì£¼|ì ì–´ì£¼)/.test(qtext)) return "ì˜¤í”ˆì‘ë‹µ";
  return "ëª¨ë¥´ê² ìŒ";
}

/* ===== ë³´ê¸°(ìš”ì•½) ìƒì„± ===== */
function buildOptionLabels(q, qtext, varsForQ, rtype){

  if (rtype === "ë¦¬ì»¤íŠ¸ì²™ë„(Matrix)") {
    const out = {};
    for (const v of varsForQ) {
      const m = v.var.match(makeRegExp(q, '_(\\d+)\\.\\s*(.*?)(?:\\s*\\(TEXT\\))?$'));
      if (m && !/\(TEXT\)$/.test(v.var)) out[m[1]] = trim(m[2]);
    }
    return out;
  }

  if (rtype === "ì¤‘ë³µì‘ë‹µ") {
    const textColByN = {};
    const codeColByN = {};
    for (const v of varsForQ) {
      let m = v.var.match(makeRegExp(q, '_(\\d+)$')); if (m) codeColByN[m[1]] = v.colIndex;
      m = v.var.match(makeRegExp(q, '_(\\d+)\\(TEXT\\)$')); if (m) { textColByN[m[1]] = v.colIndex; continue; }
      m = v.var.match(makeRegExp(q, '_(\\d+)\\.\\s*.*?\\s*\\(TEXT\\)$')); if (m && textColByN[m[1]] == null) textColByN[m[1]] = v.colIndex;
    }

    const out = {};
    const ns = sortNumericKeys({ ...textColByN, ...codeColByN });
    for (const n of ns) {
      const codeCol = codeColByN[n];
      const textCol = textColByN[n];

      let has99 = false;
      if (codeCol != null) {
        for (const r of rawRows) { if (trim(r?.[codeCol]) === "99") { has99 = true; break; } }
      }
      if (has99) { out[n] = "ê¸°íƒ€"; continue; }

      if (textCol != null) {
        for (const r of rawRows) {
          const s = trim(r?.[textCol]);
          if (s !== "") { out[n] = s; break; }
        }
      }
    }
    return out;
  }

  if (rtype === "ìˆœìœ„ì‘ë‹µ") {
    const textColByN = {};
    for (const v of varsForQ) {
      let m = v.var.match(makeRegExp(q, '_(\\d+)\\(TEXT\\)$')); if (m) { textColByN[m[1]] = v.colIndex; continue; }
      m = v.var.match(makeRegExp(q, '_(\\d+)\\.\\s*.*?\\s*\\(TEXT\\)$')); if (m && textColByN[m[1]] == null) textColByN[m[1]] = v.colIndex;
    }
    const out = {};
    const ns = sortNumericKeys(textColByN);
    for (const n of ns) {
      const col = textColByN[n];
      const uniq = new Set();
      for (const r of rawRows) {
        const s = trim(r?.[col]);
        if (s !== "") uniq.add(s);
        if (uniq.size > 1) break;
      }
      if (uniq.size === 0) continue;
      if (uniq.size > 1) out[n] = "ê¸°íƒ€"; else out[n] = Array.from(uniq)[0];
    }
    return out;
  }

  if (rtype === "ë‹¨ì¼ì‘ë‹µ" || rtype === "ë¦¬ì»¤íŠ¸ì²™ë„(ë‹¨ì¼)") {
    const baseCode = varsForQ.find(v => v.var === q);
    const baseText = varsForQ.find(v => v.var === q + "(TEXT)");
    const out = {};
    if (!baseCode || !baseText) return out;

    const cIdx = baseCode.colIndex;
    const tIdx = baseText.colIndex;
    const bucket = new Map();
    for (const r of rawRows) {
      const codeStr = toStr(r?.[cIdx]);
      const textStr = toStr(r?.[tIdx]);
      if (codeStr === "" || textStr === "") continue;
      if (!bucket.has(codeStr)) bucket.set(codeStr, new Set());
      bucket.get(codeStr).add(textStr);
    }
    for (const [code, texts] of bucket.entries()) {
      if (rtype === "ë‹¨ì¼ì‘ë‹µ" && texts.size > 1) out[code] = "ê¸°íƒ€";
      else out[code] = Array.from(texts)[0];
    }
    return out;
  }
  return {};
}

/* ===== ë¼ë²¨ ì—†ìŒ ì˜µì…˜ íƒì§€ (ì¤‘ë³µ/ìˆœìœ„ë§Œ) ===== */
function getMissingOptionNs(q, rtype, options){
  if(!(rtype==="ì¤‘ë³µì‘ë‹µ" || rtype==="ìˆœìœ„ì‘ë‹µ")) return [];
  const vars = rawColsByQ[q] || [];
  const ns = new Set();
  for(const v of vars){
    if(typeof v.var !== "string") continue;
    const m = v.var.match(makeRegExp(q, "_(\\d+)$"));
    if(m) ns.add(m[1]);
  }
  const miss = [];
  ns.forEach(n=>{
    if(options && Object.prototype.hasOwnProperty.call(options, n)) return;
    miss.push(n);
  });
  return miss.sort((a,b)=> Number(a)-Number(b));
}

/* ===== ìš”ì•½ í…Œì´ë¸” ë Œë”ë§ =====
   - ë³´ê¸°(ìš”ì•½)ì— ì—†ëŠ” ì˜µì…˜ nì€ 'ë¼ë²¨ ì—†ìŒ'ìœ¼ë¡œ í‘œì‹œ
   - â˜… ì‚¬ìš©ì ì…ë ¥ì¹¸ ì œê³µ: ê° nì— ëŒ€í•œ ë³´ê¸°ëª…ì„ ì‚¬ì „ì— ì§€ì •
*/
function renderSummary(){
  const tbody = document.querySelector('#summaryTable tbody');
  tbody.innerHTML="";
  const types = ["ë‹¨ì¼ì‘ë‹µ","ì¤‘ë³µì‘ë‹µ","ìˆœìœ„ì‘ë‹µ","ë¦¬ì»¤íŠ¸ì²™ë„(Matrix)","ë¦¬ì»¤íŠ¸ì²™ë„(ë‹¨ì¼)","ì˜¤í”ˆì‘ë‹µ","ëª¨ë¥´ê² ìŒ"];

  summary.forEach(row=>{
    const q = row["Që²ˆí˜¸"];
    const tr=document.createElement('tr');

    const tdQ=document.createElement('td'); tdQ.textContent=q; tr.appendChild(tdQ);
    const tdStem=document.createElement('td'); tdStem.textContent=row["ë¬¸í•­ë¬¸"]; tr.appendChild(tdStem);

    const tdType=document.createElement('td');
    const sel=document.createElement('select');
    types.forEach(t=>{
      const o=document.createElement('option'); o.value=t; o.textContent=t;
      if(t===row["ì‘ë‹µë°©ì‹"]) o.selected=true;
      sel.appendChild(o);
    });
    sel.addEventListener('change', ()=>{ row["ì‘ë‹µë°©ì‹"]=sel.value; renderSummary(); });
    tdType.appendChild(sel); tr.appendChild(tdType);

    const tdIdx=document.createElement('td');
    const inp=document.createElement('input'); inp.type="text"; inp.value=row["í•­ëª©ëª…(ì¸ë±ìŠ¤)"]||"";
    inp.addEventListener('input', ()=>{ row["í•­ëª©ëª…(ì¸ë±ìŠ¤)"]=inp.value; });
    tdIdx.appendChild(inp); tr.appendChild(tdIdx);

    const tdOpts=document.createElement('td');
    {
      const map = row["ë³´ê¸°(ìš”ì•½)"] || {};
      const pretty = sortNumericKeys(map)
        .map(n => `(${n})${map[n]}`)
        .join(", ");
      tdOpts.innerHTML = `<span class="mono">${escapeHtml(pretty)}</span>`;
    }

    const missingNs = getMissingOptionNs(q, row["ì‘ë‹µë°©ì‹"], row["ë³´ê¸°(ìš”ì•½)"]);
    if (missingNs.length){
      tdOpts.classList.add('flag-missing');
      tdOpts.insertAdjacentHTML('beforeend',
        `<div style="margin-top:6px">
           <span class="badge-missing">ë¼ë²¨ ì—†ìŒ</span>
           <span class="muted"> ${missingNs.join(", ")} â†’ ë¯¸ì…ë ¥ ì‹œ 'ì˜µì…˜n'ìœ¼ë¡œ í‘œì‹œë©ë‹ˆë‹¤.</span>
         </div>`);

      // â˜… ì‚¬ìš©ì ì…ë ¥ì¹¸: ê° nì— ëŒ€í•œ ì„ì‹œ ë¼ë²¨(ì¶”ì¶œ ì‹œ ë°˜ì˜)
      const edit = document.createElement('div');
      edit.className = 'missing-editor';
      for (const n of missingNs){
        const box = document.createElement('input');
        box.type = 'text';
        box.placeholder = `ì˜µì…˜${n}`;
        box.value = manualOptionLabels[q]?.[n] || "";
        box.addEventListener('input', ()=>{
          if (!manualOptionLabels[q]) manualOptionLabels[q] = {};
          manualOptionLabels[q][n] = box.value.trim();
        });
        const wrap = document.createElement('label');
        wrap.style.display = 'inline-flex';
        wrap.style.alignItems = 'center';
        wrap.style.gap = '6px';
        const tag = document.createElement('span');
        tag.className = 'muted';
        tag.textContent = `(${n})`;
        wrap.appendChild(tag);
        wrap.appendChild(box);
        edit.appendChild(wrap);
      }
      tdOpts.appendChild(edit);
    }

    tr.appendChild(tdOpts);
    tbody.appendChild(tr);
  });
}

/* ===== í—¤ë” ì ìš© & íŒŒì¼ ë‹¤ìš´ë¡œë“œ =====
   - manualOptionLabelsì— ì…ë ¥ëœ ê°’ì´ ìˆìœ¼ë©´, ë³´ê¸° ë¼ë²¨ë¡œ ìš°ì„  ì‚¬ìš©
   - ì—†ìœ¼ë©´ ê¸°ì¡´ ë¡œì§ëŒ€ë¡œ ì˜µì…˜n ì²˜ë¦¬
*/
applyBtn.addEventListener('click', ()=>{
  try{
    if (typeof XLSX === 'undefined') { alert("XLSX ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."); return; }
    if (!Array.isArray(rawAOA) || rawAOA.length < 2) { alert("Raw ë°ì´í„°ê°€ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤."); return; }
    if (!Array.isArray(rawColumns) || rawColumns.length === 0) { alert("êµ¬ì¡° ì¸ì‹ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤."); return; }
    if (!Array.isArray(summary) || summary.length === 0) { alert("ìš”ì•½(summary)ì´ ë¹„ì–´ ìˆìŠµë‹ˆë‹¤."); return; }

    const h0raw = Array.isArray(rawAOA[0]) ? rawAOA[0] : [];
    const h1raw = Array.isArray(rawAOA[1]) ? rawAOA[1] : [];
    const maxLen = Math.max(h0raw.length, h1raw.length);
    const newH0 = Array.from({length:maxLen}, (_,i)=> String(h0raw[i] ?? ""));
    const newH1 = Array.from({length:maxLen}, (_,i)=> String(h1raw[i] ?? ""));

    const summaryByQ = {};
    for (const row of summary) summaryByQ[row["Që²ˆí˜¸"]] = row;
    const getOptionsMap = (q) => (summaryByQ[q] ? (summaryByQ[q]["ë³´ê¸°(ìš”ì•½)"] || {}) : {});
    const getIndexName = (q) => (summaryByQ[q] ? (summaryByQ[q]["í•­ëª©ëª…(ì¸ë±ìŠ¤)"] || "") : "");

    for (const col of rawColumns){
      const vname = String(col.var ?? "");
      const q = extractQnumFromQtext(col.qtext) || extractQnumFromVar(vname);
      if(!q || !summaryByQ[q]){ 
        newH0[col.colIndex] = String(h0raw[col.colIndex] ?? "");
        newH1[col.colIndex] = String(h1raw[col.colIndex] ?? "");
        continue;
      }

      const rtype = summaryByQ[q]["ì‘ë‹µë°©ì‹"];
      const idxName = getIndexName(q);
      const options = getOptionsMap(q);

      let L0 = String(h0raw[col.colIndex] ?? "");
      let L1 = String(h1raw[col.colIndex] ?? "");

      // helper: ì„ íƒëœ ìˆ˜ê¸° ë¼ë²¨ ìš°ì„  ì ìš©
      const pickLabel = (q, n, fallback) => {
        const manual = manualOptionLabels[q]?.[n];
        return (options[n] || (manual && manual.trim()) || fallback);
      };

      if (rtype === "ë¦¬ì»¤íŠ¸ì²™ë„(Matrix)") {
        const m = vname.match(makeRegExp(q, '_(\\d+)(?:\\.|\\(TEXT\\))?'));
        if (m){
          const n = m[1];
          const isText = /\(TEXT\)$/.test(vname);
          let label = options[n];
          if (!label) {
            const m2 = vname.match(makeRegExp(q, '_'+n+'\\.\\s*(.*?)(?:\\s*\\(TEXT\\))?$'));
            label = m2 ? trim(m2[1]) : pickLabel(q, n, `ì˜µì…˜${n}`);
          }
          L0 = `${q}. ${idxName ? idxName + "_" : ""}${label}`;
          L1 = isText ? "(TEXT)" : "";
        }

      } else if (rtype === "ì¤‘ë³µì‘ë‹µ" || rtype === "ìˆœìœ„ì‘ë‹µ") {
        const isText = /\(TEXT\)$/.test(vname);
        const mCode = vname.match(makeRegExp(q, '_(\\d+)$'));
        const mText = vname.match(makeRegExp(q, '_(\\d+)\\(TEXT\\)$'));
        if (mCode || mText) {
          const n = (mCode ? mCode[1] : mText[1]);
          const label = pickLabel(q, n, `ì˜µì…˜${n}`);
          L0 = `${q}. ${idxName ? idxName + "_" : ""}${label}`;
          L1 = isText ? "(TEXT)" : (rtype === "ìˆœìœ„ì‘ë‹µ" ? "(ìˆœìœ„)" : "(ì„ íƒ)");
        }

      } else if (rtype === "ë‹¨ì¼ì‘ë‹µ" || rtype === "ë¦¬ì»¤íŠ¸ì²™ë„(ë‹¨ì¼)") {
        if (vname === q) {
          L0 = `${q}. ${idxName || ""}`; L1 = "(ì½”ë“œ)";
        } else if (vname === `${q}(TEXT)`) {
          L0 = `${q}. ${idxName || ""}`; L1 = "(TEXT)";
        } else {
          const m = vname.match(makeRegExp(q, '_(\\d+)(?:\\(TEXT\\))?$'));
          if (m) {
            const n = m[1];
            const isText = /\(TEXT\)$/.test(vname);
            const label = pickLabel(q, n, `ì˜µì…˜${n}`);
            L0 = `${q}. ${idxName ? idxName + "_" : ""}${label}`;
            L1 = isText ? "(TEXT)" : "";
          }
        }

      } else if (rtype === "ì˜¤í”ˆì‘ë‹µ") {
        if (vname === q) {
          L0 = `${q}. ${idxName || ""}`; L1 = "(ì½”ë“œ)";
        } else if (vname === `${q}(TEXT)`) {
          L0 = `${q}. ${idxName || ""}`; L1 = "(TEXT)";
        }
      }
      newH0[col.colIndex] = L0;
      newH1[col.colIndex] = L1;
    }

    const dataStartRow = 2;
    let flatHeader = newH0.map((a,i)=> a + (newH1[i] ? newH1[i] : ""));
    flatHeader = flatHeader.map(h => h.replace(/\s*\((ì„ íƒ|ìˆœìœ„|ì½”ë“œ)\)\s*$/gi, ""));
    const dataAoA = [ flatHeader, ...rawAOA.slice(dataStartRow) ];

    const codeOnly = document.getElementById('optCodeOnly')?.checked;
    const textOnly = document.getElementById('optTextOnly')?.checked;

    const keepIdxs = [];
    for (let i = 0; i < flatHeader.length; i++) {
      const isMeta = i < 4;
      const isText = /\(TEXT\)$/i.test(flatHeader[i]);
      if (!codeOnly && !textOnly) { keepIdxs.push(i); continue; }
      if (codeOnly && (isMeta || !isText)) keepIdxs.push(i);
      if (textOnly && (isMeta ||  isText)) keepIdxs.push(i);
    }
    const filteredAoA = dataAoA.map(row => keepIdxs.map(i => row[i]));

    const outWB = XLSX.utils.book_new();
    const wsData = XLSX.utils.aoa_to_sheet(filteredAoA);
    XLSX.utils.book_append_sheet(outWB, wsData, "data");

    let fname = "raw_renamed.xlsx";
    if (codeOnly) fname = "raw_renamed_code.xlsx";
    if (textOnly) fname = "raw_renamed_text.xlsx";
    XLSX.writeFile(outWB, fname);
  }catch(err){
    console.error('[apply] ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜:', err);
    alert("í—¤ë” ì ìš© ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.\në¸Œë¼ìš°ì € ì½˜ì†”(F12)ì—ì„œ ì˜¤ë¥˜ ë©”ì‹œì§€ë¥¼ í™•ì¸í•´ ì£¼ì„¸ìš”.");
  }
});

/* ===== AI ì¸ë±ìŠ¤ ìë™ ìƒì„± (í”„ë¡ì‹œë§Œ ì‚¬ìš©) ===== */
async function aiFillIndexNamesIfEmpty(){
  const aiBtn = document.getElementById('aiNameBtn');
  const oldBtnText = aiBtn ? aiBtn.textContent : '';
  if (aiBtn) { aiBtn.disabled = true; aiBtn.textContent = 'ìƒì„± ì¤‘â€¦'; }

  try {
    if (!Array.isArray(summary) || summary.length === 0) {
      alert("ë¨¼ì € 'ì„¤ë¬¸ êµ¬ì¡° í™•ì¸'ì„ ì‹¤í–‰í•´ ìš”ì•½ì„ ë§Œë“  ë’¤ ì‹œë„í•˜ì„¸ìš”.");
      return;
    }

    const sys = "ë„ˆëŠ” ì†Œë¹„ìì¡°ì‚¬ ì„¤ë¬¸ ì „ë¬¸ê°€ì•¼. ì‚¬ìš©ìê°€ ì¸ë±ìŠ¤ë§Œ ë³´ê³ ë„ í•´ë‹¹ ë¬¸í•­ì´ ì–´ë–¤ ë¬¸í•­ì¸ì§€ ì•Œ ìˆ˜ ìˆê²Œ, ì•„ì£¼ ì§§ê³  ëª…ë£Œí•œ í•œêµ­ì–´ ì¸ë±ìŠ¤(ìµœëŒ€ 20ì)ë¥¼ ì§€ì–´ì¤˜. ê° ë¬¸í•­ì˜ ì¸ë±ìŠ¤ëŠ” ê°€ëŠ¥í•œ ì„œë¡œ ë‹¤ë¥´ê²Œ ì§€ì–´ì ¸ì•¼ í•´. Që²ˆí˜¸ë‚˜ ìˆ«ì, íŠ¹ìˆ˜ê¸°í˜¸ë¥¼ ë¶™ì´ì§€ ë§ê³ , ë¬¸í•­ì´ ì¡°ì‚¬í•˜ê³ ì í•˜ëŠ” ë°”ê°€ ë¬´ì—‡ì¸ì§€ ì˜ ë“œëŸ¬ë‚˜ê²Œ ì§€ì–´ì¤˜. ë¬¸í•­ ë‚´ì— ì¹´í…Œê³ ë¦¬ëª…ì´ë‚˜ ë¸Œëœë“œëª…ì´ ê°ì§€ë˜ëŠ” ê²½ìš° ê·¸ê²ƒë„ ì¸ë±ìŠ¤ëª…ì— ë“œëŸ¬ë‚˜ë„ë¡ ì‘ì„±í•´ì¤˜(ex. 'ê·€í•˜ê»˜ì„œ ì˜¤ëŠ˜ ì´ì „ êµ­ë‚´ ê¸°ì—…ìœ¼ë¡œ ì•Œê³  ê³„ì…¨ë˜ ë¸Œëœë“œë¥¼ ëª¨ë‘ ì„ íƒí•´ì£¼ì„¸ìš”' --> êµ­ë‚´ê¸°ì—… ë³´ì¡°ì¸ì§€ë„, 'ìŒë£Œìˆ˜ í•˜ë©´ ë– ì˜¤ë¥´ëŠ” ë¸Œëœë“œë¥¼ í•œê°€ì§€ë§Œ ì‘ì„±í•´ì£¼ì„¸ìš”' --> ìŒë£Œìˆ˜ ìµœì´ˆìƒê¸°... ë“±)";
    const MODEL_FOR_PROXY = "gpt-4o-mini"; //

    log(tkLog, `AI ì¸ë±ìŠ¤ ìƒì„± ì‹œì‘: 0 / ${summary.length}`);

    for (let i = 0; i < summary.length; i++) {
      log(tkLog, `AI ì¸ë±ìŠ¤ ìƒì„±: ${i+1} / ${summary.length}`);
      const r = summary[i];
      if (String(r["í•­ëª©ëª…(ì¸ë±ìŠ¤)"]||"").trim() !== "") continue;

      const userPayload = JSON.stringify({
        Që²ˆí˜¸: r["Që²ˆí˜¸"],
        ë¬¸í•­ë¬¸: r["ë¬¸í•­ë¬¸"],
        ì‘ë‹µë°©ì‹: r["ì‘ë‹µë°©ì‹"],
        ë³´ê¸°ìš”ì•½: r["ë³´ê¸°(ìš”ì•½)"]
      });

      let named = "";
      try {
        const preq = {
          method: "POST",
          headers: Object.assign(
            { "Content-Type": "application/json" },
            TEAM_TOKEN ? { "x-team-token": TEAM_TOKEN } : {}
          ),
          body: JSON.stringify({
            model: MODEL_FOR_PROXY,
            prompt: {
              system: sys,
              user: `ì•„ë˜ ë¬¸í•­ì— ëŒ€í•œ 'í•­ëª©ëª…(ì¸ë±ìŠ¤)'ë¥¼ í•œ ê°œë§Œ ì œì‹œí•´ì¤˜.\n${userPayload}\n\nì¶œë ¥í˜•ì‹: ì¸ë±ìŠ¤ë§Œ ë”± í•œ ì¤„`
            },
            maxTokens: 50
          })
        };
        const presp = await fetch(AI_PROXY_PATH, preq);
        if (!presp.ok) throw new Error(`HTTP ${presp.status}`);
        const pdata = await presp.json();

        named = (pdata?.choices?.[0]?.message?.content || pdata?.text || pdata?.content || "").trim();
        named = named.replace(/^[\"'ã€Œã€]|[\"'ã€ã€]$/g, "").split(/\r?\n/)[0].trim();
        if (named.length > 20) named = named.slice(0, 20);
        if (!named) named = makeIndexNameMinimal(r["Që²ˆí˜¸"], r["ë¬¸í•­ë¬¸"]);
      } catch (e) {
        log(tkLog, `[AI í”„ë¡ì‹œ ì˜¤ë¥˜] ${e?.message || e}`);
        named = makeIndexNameMinimal(r["Që²ˆí˜¸"], r["ë¬¸í•­ë¬¸"]);
      }

      r["í•­ëª©ëª…(ì¸ë±ìŠ¤)"] = named;
    }

    // ì¤‘ë³µ ì¸ë±ìŠ¤ ì ‘ë¯¸ì‚¬ ì²˜ë¦¬(í˜„í–‰ ìœ ì§€)
    const count = {};
    for (const r of summary) {
      const base = r["í•­ëª©ëª…(ì¸ë±ìŠ¤)"];
      count[base] = (count[base] || 0) + 1;
      if (count[base] > 1) r["í•­ëª©ëª…(ì¸ë±ìŠ¤)"] = `${base} (${count[base]})`;
    }

    renderSummary();
    log(tkLog, `AI ì¸ë±ìŠ¤ ìƒì„± ì™„ë£Œ: ${summary.length} / ${summary.length}`);
    alert("AI ë³´ì™„ ì™„ë£Œ: ë¹„ì–´ ìˆë˜ ì¸ë±ìŠ¤ ì¹¸ì„ ì±„ì› ìŠµë‹ˆë‹¤.");
  } finally {
    // â˜… ì–´ë–¤ ê²½ë¡œì—¬ë„ ë²„íŠ¼ ë³µêµ¬
    if (aiBtn) { aiBtn.disabled = false; aiBtn.textContent = oldBtnText; }
  }
}

/* ===== ì´ë²¤íŠ¸ ë°”ì¸ë”© ===== */
document.getElementById('aiNameBtn')?.addEventListener('click', aiFillIndexNamesIfEmpty);

/* ===== ì´ˆê¸° ì•ˆë‚´ ë°°ì¹˜(í˜„í–‰ ìœ ì§€) ===== */
document.addEventListener('DOMContentLoaded', ()=>{
  const notice = document.getElementById('brandNotice');
  const title = document.querySelector('h1');
  if(notice && title){ title.insertAdjacentElement('afterend', notice); }
  
  // â˜… To-Know ì²´í¬ë°•ìŠ¤ ë®¤í…ìŠ¤ ì¦‰ì‹œ ì ìš©
  const useGroupPref = document.getElementById('useGroupPref');
  const useSubLabel = document.getElementById('useSubLabel');
  if(useGroupPref && useSubLabel){
    // ì´ˆê¸° ìƒíƒœ: ë‘˜ ë‹¤ ì²´í¬ë˜ì–´ ìˆìœ¼ë©´ í•˜ìœ„êµ¬ë¶„ë§Œ í•´ì œ
    if(useGroupPref.checked && useSubLabel.checked){
      useSubLabel.checked = false;
    }
    
    // â˜… í˜ì´ì§€ ë¡œë“œ ì‹œ ì¦‰ì‹œ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡!
    const syncMutexHandler = (ev) => {
      if(ev && ev.target===useGroupPref){
        useSubLabel.checked = false;
      }
      if(ev && ev.target===useSubLabel){
        useGroupPref.checked = false;
      }
    };
    useGroupPref.addEventListener('change', syncMutexHandler);
    useSubLabel.addEventListener('change', syncMutexHandler);
  }
});

/* ===== ë‚´ë ¤ë°›ê¸° ì˜µì…˜ ìƒí˜¸ë°°ì œ (í˜„í–‰ ìœ ì§€) ===== */
document.addEventListener('DOMContentLoaded', function () {
  const codeOnly = document.getElementById('optCodeOnly');
  const textOnly = document.getElementById('optTextOnly');
  if (!codeOnly || !textOnly) return;
  const makeExclusive = (src, other) => { if (src.checked) other.checked = false; };
  ['change', 'click'].forEach(evt => {
    codeOnly.addEventListener(evt, () => makeExclusive(codeOnly, textOnly));
    textOnly.addEventListener(evt, () => makeExclusive(textOnly, codeOnly));
  });
});
</script>
</body>
</html>
